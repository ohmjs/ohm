'use strict';

const fastGlob = require('fast-glob');
const fs = require('fs');
const ohm = require('ohm-js');
const path = require('path');

const {generateTypes} = require('../../helpers/generateTypes');

const OHM_FILE_EXT = '.ohm';

function assertFileExtensionEquals(filename, ext) {
  const actual = path.extname(filename);
  if (actual !== ext) {
    throw new Error(`Wrong file extension: expected '${ext}', got '${actual}'`);
  }
}

class Plan {
  constructor() {
    this.plan = {filesToWrite: Object.create(null)};
  }

  write(filename, contents) {
    this.plan.filesToWrite[filename] = contents;
  }
}

class Writer {
  constructor(basePath) {
    this.basePath = basePath || '';
  }

  write(filename, contents) {
    const outputPath = path.join(this.basePath, filename);
    console.log(outputPath); // eslint-disable-line no-console
    fs.writeFileSync(outputPath, contents);
  }
}

const createBanner = (filename = undefined) =>
  `// AUTOGENERATED FILE
// This file was generated${filename ? ` from ${filename}` : ''} by \`ohm generateRecipes\`.`;

function generateRecipes(patterns, opts) {
  const {dryRun, cwd, withTypes} = opts;
  const plan = new Plan();
  const writer = dryRun ? plan : new Writer(cwd);

  for (const sourceFilename of fastGlob.sync(patterns, {cwd})) {
    const sourcePath = cwd ? path.join(cwd, sourceFilename) : sourceFilename;

    // Don't process any files that don't have the right file extension.
    if (path.extname(sourcePath) !== OHM_FILE_EXT) continue;

    const grammarSource = fs.readFileSync(sourcePath, 'utf-8');
    const grammars = ohm.grammars(grammarSource);
    generateRecipe(sourceFilename, grammars, writer);
    if (withTypes) {
      generateTypesWithWriter(sourceFilename, grammars, writer);
    }
  }

  return plan.plan;
}

function generateRecipe(grammarPath, grammars, writer) {
  assertFileExtensionEquals(grammarPath, OHM_FILE_EXT);

  const outputFilename = `${grammarPath}-recipe.js`;
  const isSingleGrammar = Object.keys(grammars).length === 1;

  let output = "'use strict';const ohm=require('ohm-js');";

  // If it's a single-grammar source file, the default export is the grammar.
  // Otherwise, the export is a (possibly empty) Namespace containing the grammars.
  if (!isSingleGrammar) {
    output += 'const ns=module.exports=ohm.createNamespace();';
  }
  for (const [name, grammar] of Object.entries(grammars)) {
    const {superGrammar} = grammar;
    const superGrammarExpr = superGrammar.isBuiltIn() ? undefined : `ns.${superGrammar.name}`;
    output += isSingleGrammar ? 'module.exports=' : `ns.${name}=`;
    output += `ohm.makeRecipe(${grammar.toRecipe(superGrammarExpr)});`;
  }
  writer.write(outputFilename, output);
}

function generateTypesWithWriter(grammarPath, grammars, writer) {
  assertFileExtensionEquals(grammarPath, OHM_FILE_EXT);

  const filename = path.basename(grammarPath);
  const contents = [createBanner(filename), '', generateTypes(grammars), ''].join('\n');
  writer.write(`${grammarPath}-recipe.d.ts`, contents);
}

module.exports = {
  command: 'generateRecipes <patterns...>',
  description: 'generate standalone modules (aka "recipes") from .ohm files',
  options: [['-t, --withTypes', 'generate a corresponding .d.ts file for TypeScript']],
  action: generateRecipes
};
