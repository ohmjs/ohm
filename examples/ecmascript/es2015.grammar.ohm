ES2015 {

  sourceCharacter = any

  inputElementDiv = 
    | whiteSpace
    | lineTerminator
    | comment
    | commonToken
    | divPunctuator
    | rightBracePunctuator

  inputElementRegExp = 
    | whiteSpace
    | lineTerminator
    | comment
    | commonToken
    | rightBracePunctuator
    | regularExpressionLiteral

  inputElementRegExpOrTemplateTail = 
    | whiteSpace
    | lineTerminator
    | comment
    | commonToken
    | regularExpressionLiteral
    | templateSubstitutionTail

  inputElementTemplateTail = 
    | whiteSpace
    | lineTerminator
    | comment
    | commonToken
    | divPunctuator
    | templateSubstitutionTail

  whiteSpace = 
    | "\t"
    | "\x0B"
    | "\x0C"
    | " "
    | "\xA0"
    | "\uFEFF"
    | "" /* FIXME <USP> */

  lineTerminator = 
    | "\n"
    | "\r"
    | "\u2028"
    | "\u2029"

  lineTerminatorSequence = 
    | "\n" -- a0
    | "\r" ~"\n" -- a1
    | "\u2028" -- a2
    | "\u2029" -- a3
    | "\r" "\n" -- a4

  comment = 
    | multiLineComment
    | singleLineComment

  multiLineComment = 
    | "/*" multiLineCommentChars? "*/" -- a0

  multiLineCommentChars = 
    | multiLineNotAsteriskChar multiLineCommentChars? -- a0
    | "*" postAsteriskCommentChars? -- a1

  postAsteriskCommentChars = 
    | multiLineNotForwardSlashOrAsteriskChar multiLineCommentChars? -- a0
    | "*" postAsteriskCommentChars? -- a1

  multiLineNotAsteriskChar = 
    | ~"*" sourceCharacter

  multiLineNotForwardSlashOrAsteriskChar = 
    | ~("/" | "*") sourceCharacter

  singleLineComment = 
    | "//" singleLineCommentChars? -- a0

  singleLineCommentChars = 
    | singleLineCommentChar singleLineCommentChars? -- a0

  singleLineCommentChar = 
    | ~lineTerminator sourceCharacter

  commonToken = 
    | identifierName
    | punctuator
    | numericLiteral
    | stringLiteral
    | template

  identifierName = 
    | identifierStart -- a0
    | identifierName identifierPart -- a1

  identifierStart = 
    | unicodeIDStart -- a0
    | "$" -- a1
    | "_" -- a2
    | "\\" unicodeEscapeSequence -- a3

  identifierPart = 
    | unicodeIDContinue -- a0
    | "$" -- a1
    | "_" -- a2
    | "\\" unicodeEscapeSequence -- a3
    | "" /* FIXME <ZWNJ> */ -- a4
    | "" /* FIXME <ZWJ> */ -- a5

  unicodeIDStart = letter /* fixme */

  unicodeIDContinue = letter | digit /* fixme */

  reservedWord = 
    | keyword
    | futureReservedWord
    | nullLiteral
    | booleanLiteral

  keyword = "break" | "do" | "in" | "typeof" | "case" | "else" | "instanceof" | "var" | "catch" | "export" | "new" | "void" | "class" | "extends" | "return" | "while" | "const" | "finally" | "super" | "with" | "continue" | "for" | "switch" | "yield" | "debugger" | "function" | "this" | "default" | "if" | "throw" | "delete" | "import" | "try"

  futureReservedWord = "enum" | "await" | "implements" | "package" | "protected" | "interface" | "private" | "public"

  punctuator = "{" | "}" | "(" | ")" | "[" | "]" | "." | ";" | "," | "<" | ">" | "<=" | ">=" | "==" | "!=" | "===" | "!==" | "+" | "-" | "*" | "%" | "++" | "--" | "<<" | ">>" | ">>>" | "&" | "|" | "^" | "!" | "~" | "&&" | "||" | "?" | " ::" | "=" | "+=" | "-=" | "*=" | "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "|=" | "^=" | "=>"

  divPunctuator = "/" | "/="

  rightBracePunctuator = ")"

  nullLiteral = 
    | "null"

  booleanLiteral = 
    | "true"
    | "false"

  numericLiteral = 
    | decimalLiteral
    | binaryIntegerLiteral
    | octalIntegerLiteral
    | hexIntegerLiteral

  decimalLiteral = 
    | decimalIntegerLiteral "." decimalDigits? exponentPart? -- a0
    | "." decimalDigits exponentPart? -- a1
    | decimalIntegerLiteral exponentPart? -- a2

  decimalIntegerLiteral = 
    | "0" -- a0
    | nonZeroDigit decimalDigits? -- a1

  decimalDigits = 
    | decimalDigit -- a0
    | decimalDigits decimalDigit -- a1

  decimalDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

  nonZeroDigit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

  exponentPart = 
    | exponentIndicator signedInteger -- a0

  exponentIndicator = "e" | "E"

  signedInteger = 
    | decimalDigits -- a0
    | "+" decimalDigits -- a1
    | "-" decimalDigits -- a2

  binaryIntegerLiteral = 
    | "0b" binaryDigits -- a0
    | "0B" binaryDigits -- a1

  binaryDigits = 
    | binaryDigit -- a0
    | binaryDigits binaryDigit -- a1

  binaryDigit = "0" | "1"

  octalIntegerLiteral = 
    | "0o" octalDigits -- a0
    | "0O" octalDigits -- a1

  octalDigits = 
    | octalDigit -- a0
    | octalDigits octalDigit -- a1

  octalDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"

  hexIntegerLiteral = 
    | "0x" hexDigits -- a0
    | "0X" hexDigits -- a1

  hexDigits = 
    | hexDigit -- a0
    | hexDigits hexDigit -- a1

  hexDigit := "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"

  stringLiteral = 
    | "\"" doubleStringCharacters? "\"" -- a0
    | "'" singleStringCharacters? "'" -- a1

  doubleStringCharacters = 
    | doubleStringCharacter doubleStringCharacters? -- a0

  singleStringCharacters = 
    | singleStringCharacter singleStringCharacters? -- a0

  doubleStringCharacter = 
    | ~("\"" | "\\" | lineTerminator) sourceCharacter -- a0
    | "\\" escapeSequence -- a1
    | lineContinuation -- a2

  singleStringCharacter = 
    | ~("'" | "\\" | lineTerminator) sourceCharacter -- a0
    | "\\" escapeSequence -- a1
    | lineContinuation -- a2

  lineContinuation = 
    | "\\" lineTerminatorSequence -- a0

  escapeSequence = 
    | characterEscapeSequence -- a0
    | "0" /* FIXME Assertion: lookahead <! DecimalDigit */ -- a1
    | hexEscapeSequence -- a2
    | unicodeEscapeSequence -- a3

  characterEscapeSequence = 
    | singleEscapeCharacter
    | nonEscapeCharacter

  singleEscapeCharacter = "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v"

  nonEscapeCharacter = 
    | ~(escapeCharacter | lineTerminator) sourceCharacter

  escapeCharacter = 
    | singleEscapeCharacter
    | decimalDigit
    | "x"
    | "u"

  hexEscapeSequence = 
    | "x" hexDigit hexDigit -- a0

  unicodeEscapeSequence = 
    | "u" hex4Digits -- a0
    | "u{" hexDigits "}" -- a1

  hex4Digits = 
    | hexDigit hexDigit hexDigit hexDigit -- a0

  regularExpressionLiteral = 
    | "/" regularExpressionBody "/" regularExpressionFlags -- a0

  regularExpressionBody = 
    | regularExpressionFirstChar regularExpressionChars -- a0

  regularExpressionChars = 
    | "" -- a0
    | regularExpressionChars regularExpressionChar -- a1

  regularExpressionFirstChar = 
    | ~("*" | "\\" | "/" | "[") regularExpressionNonTerminator
    | regularExpressionBackslashSequence
    | regularExpressionClass

  regularExpressionChar = 
    | ~("\\" | "/" | "[") regularExpressionNonTerminator
    | regularExpressionBackslashSequence
    | regularExpressionClass

  regularExpressionBackslashSequence = 
    | "\\" regularExpressionNonTerminator -- a0

  regularExpressionNonTerminator = 
    | ~lineTerminator sourceCharacter

  regularExpressionClass = 
    | "[" regularExpressionClassChars "]" -- a0

  regularExpressionClassChars = 
    | "" -- a0
    | regularExpressionClassChars regularExpressionClassChar -- a1

  regularExpressionClassChar = 
    | ~("]" | "\\") regularExpressionNonTerminator
    | regularExpressionBackslashSequence

  regularExpressionFlags = 
    | "" -- a0
    | regularExpressionFlags identifierPart -- a1

  template = 
    | noSubstitutionTemplate
    | templateHead

  noSubstitutionTemplate = 
    | "`" templateCharacters? "`" -- a0

  templateHead = 
    | "`" templateCharacters? "${" -- a0

  templateSubstitutionTail = 
    | templateMiddle
    | templateTail

  templateMiddle = 
    | "}" templateCharacters? "${" -- a0

  templateTail = 
    | "}" templateCharacters? "`" -- a0

  templateCharacters = 
    | templateCharacter templateCharacters? -- a0

  templateCharacter = 
    | "$" ~"{" -- a0
    | "\\" escapeSequence -- a1
    | lineContinuation -- a2
    | lineTerminatorSequence -- a3
    | ~("`" | "\\" | "$" | lineTerminator) sourceCharacter -- a4

  IdentifierReference<guardYield> = 
    | Identifier -- a0
    | guardYield "yield" -- a1

  BindingIdentifier<guardYield> = 
    | Identifier -- a0
    | guardYield "yield" -- a1

  LabelIdentifier<guardYield> = 
    | Identifier -- a0
    | guardYield "yield" -- a1

  Identifier = 
    | ~reservedWord identifierName

  PrimaryExpression<guardYield> = 
    | "this"
    | IdentifierReference<noYield>
    | Literal
    | ArrayLiteral<noYield>
    | ObjectLiteral<noYield>
    | FunctionExpression
    | ClassExpression<noYield>
    | GeneratorExpression
    | regularExpressionLiteral
    | TemplateLiteral<noYield>
    | CoverParenthesizedExpressionAndArrowParameterList<noYield>

  CoverParenthesizedExpressionAndArrowParameterList<guardYield> = 
    | "(" Expression<noIn, noYield> ")" -- a0
    | "(" ")" -- a1
    | "(" "..." BindingIdentifier<noYield> ")" -- a2
    | "(" Expression<noIn, noYield> "," "..." BindingIdentifier<noYield> ")" -- a3

  Literal = 
    | nullLiteral
    | booleanLiteral
    | numericLiteral
    | stringLiteral

  ArrayLiteral<guardYield> = 
    | "[" Elision? "]" -- a0
    | "[" ElementList<noYield> "]" -- a1
    | "[" ElementList<noYield> "," Elision? "]" -- a2

  ElementList<guardYield> = 
    | Elision? AssignmentExpression<noIn, noYield> -- a0
    | Elision? SpreadElement<noYield> -- a1
    | ElementList<noYield> "," Elision? AssignmentExpression<noIn, noYield> -- a2
    | ElementList<noYield> "," Elision? SpreadElement<noYield> -- a3

  Elision = 
    | "," -- a0
    | Elision "," -- a1

  SpreadElement<guardYield> = 
    | "..." AssignmentExpression<noIn, noYield> -- a0

  ObjectLiteral<guardYield> = 
    | "{" "}" -- a0
    | "{" PropertyDefinitionList<noYield> "}" -- a1
    | "{" PropertyDefinitionList<noYield> "," "}" -- a2

  PropertyDefinitionList<guardYield> = 
    | PropertyDefinition<noYield> -- a0
    | PropertyDefinitionList<noYield> "," PropertyDefinition<noYield> -- a1

  PropertyDefinition<guardYield> = 
    | IdentifierReference<noYield> -- a0
    | CoverInitializedName<noYield> -- a1
    | PropertyName<noYield> ":" AssignmentExpression<noIn, noYield> -- a2
    | MethodDefinition<noYield> -- a3

  PropertyName<guardYield> = 
    | LiteralPropertyName
    | ComputedPropertyName<noYield>

  LiteralPropertyName = 
    | identifierName
    | stringLiteral
    | numericLiteral

  ComputedPropertyName<guardYield> = 
    | "[" AssignmentExpression<noIn, noYield> "]" -- a0

  CoverInitializedName<guardYield> = 
    | IdentifierReference<noYield> Initializer<noIn, noYield> -- a0

  Initializer<guardIn, guardYield> = 
    | "=" AssignmentExpression<noIn, noYield> -- a0

  TemplateLiteral<guardYield> = 
    | noSubstitutionTemplate -- a0
    | templateHead Expression<noIn, noYield> TemplateSpans<noYield> -- a1

  TemplateSpans<guardYield> = 
    | templateTail -- a0
    | TemplateMiddleList<noYield> templateTail -- a1

  TemplateMiddleList<guardYield> = 
    | templateMiddle Expression<noIn, noYield> -- a0
    | TemplateMiddleList<noYield> templateMiddle Expression<noIn, noYield> -- a1

  MemberExpression<guardYield> = 
    | PrimaryExpression<noYield> -- a0
    | MemberExpression<noYield> "[" Expression<noIn, noYield> "]" -- a1
    | MemberExpression<noYield> "." identifierName -- a2
    | MemberExpression<noYield> TemplateLiteral<noYield> -- a3
    | SuperProperty<noYield> -- a4
    | MetaProperty -- a5
    | "new" MemberExpression<noYield> Arguments<noYield> -- a6

  SuperProperty<guardYield> = 
    | "super" "[" Expression<noIn, noYield> "]" -- a0
    | "super" "." identifierName -- a1

  MetaProperty = 
    | NewTarget

  NewTarget = 
    | "new" "." "target" -- a0

  NewExpression<guardYield> = 
    | MemberExpression<noYield> -- a0
    | "new" NewExpression<noYield> -- a1

  CallExpression<guardYield> = 
    | MemberExpression<noYield> Arguments<noYield> -- a0
    | SuperCall<noYield> -- a1
    | CallExpression<noYield> Arguments<noYield> -- a2
    | CallExpression<noYield> "[" Expression<noIn, noYield> "]" -- a3
    | CallExpression<noYield> "." identifierName -- a4
    | CallExpression<noYield> TemplateLiteral<noYield> -- a5

  SuperCall<guardYield> = 
    | "super" Arguments<noYield> -- a0

  Arguments<guardYield> = 
    | "(" ")" -- a0
    | "(" ArgumentList<noYield> ")" -- a1

  ArgumentList<guardYield> = 
    | AssignmentExpression<noIn, noYield> -- a0
    | "..." AssignmentExpression<noIn, noYield> -- a1
    | ArgumentList<noYield> "," AssignmentExpression<noIn, noYield> -- a2
    | ArgumentList<noYield> "," "..." AssignmentExpression<noIn, noYield> -- a3

  LeftHandSideExpression<guardYield> = 
    | NewExpression<noYield>
    | CallExpression<noYield>

  PostfixExpression<guardYield> = 
    | LeftHandSideExpression<noYield> -- a0
    | LeftHandSideExpression<noYield> ~lineTerminator "++" -- a1
    | LeftHandSideExpression<noYield> ~lineTerminator "--" -- a2

  UnaryExpression<guardYield> = 
    | PostfixExpression<noYield> -- a0
    | "delete" UnaryExpression<noYield> -- a1
    | "void" UnaryExpression<noYield> -- a2
    | "typeof" UnaryExpression<noYield> -- a3
    | "++" UnaryExpression<noYield> -- a4
    | "--" UnaryExpression<noYield> -- a5
    | "+" UnaryExpression<noYield> -- a6
    | "-" UnaryExpression<noYield> -- a7
    | "~" UnaryExpression<noYield> -- a8
    | "!" UnaryExpression<noYield> -- a9

  MultiplicativeExpression<guardYield> = 
    | UnaryExpression<noYield> -- a0
    | MultiplicativeExpression<noYield> MultiplicativeOperator UnaryExpression<noYield> -- a1

  MultiplicativeOperator = "*" | "/" | "%"

  AdditiveExpression<guardYield> = 
    | MultiplicativeExpression<noYield> -- a0
    | AdditiveExpression<noYield> "+" MultiplicativeExpression<noYield> -- a1
    | AdditiveExpression<noYield> "-" MultiplicativeExpression<noYield> -- a2

  ShiftExpression<guardYield> = 
    | AdditiveExpression<noYield> -- a0
    | ShiftExpression<noYield> "<<" AdditiveExpression<noYield> -- a1
    | ShiftExpression<noYield> ">>" AdditiveExpression<noYield> -- a2
    | ShiftExpression<noYield> ">>>" AdditiveExpression<noYield> -- a3

  RelationalExpression<guardIn, guardYield> = 
    | ShiftExpression<noYield> -- a0
    | RelationalExpression<noIn, noYield> "<" ShiftExpression<noYield> -- a1
    | RelationalExpression<noIn, noYield> ">" ShiftExpression<noYield> -- a2
    | RelationalExpression<noIn, noYield> "<=" ShiftExpression<noYield> -- a3
    | RelationalExpression<noIn, noYield> ">=" ShiftExpression<noYield> -- a4
    | RelationalExpression<noIn, noYield> "instanceof" ShiftExpression<noYield> -- a5
    | guardIn RelationalExpression<noIn, noYield> "in" ShiftExpression<noYield> -- a6

  EqualityExpression<guardIn, guardYield> = 
    | RelationalExpression<noIn, noYield> -- a0
    | EqualityExpression<noIn, noYield> "==" RelationalExpression<noIn, noYield> -- a1
    | EqualityExpression<noIn, noYield> "!=" RelationalExpression<noIn, noYield> -- a2
    | EqualityExpression<noIn, noYield> "===" RelationalExpression<noIn, noYield> -- a3
    | EqualityExpression<noIn, noYield> "!==" RelationalExpression<noIn, noYield> -- a4

  BitwiseANDExpression<guardIn, guardYield> = 
    | EqualityExpression<noIn, noYield> -- a0
    | BitwiseANDExpression<noIn, noYield> "&" EqualityExpression<noIn, noYield> -- a1

  BitwiseXORExpression<guardIn, guardYield> = 
    | BitwiseANDExpression<noIn, noYield> -- a0
    | BitwiseXORExpression<noIn, noYield> "^" BitwiseANDExpression<noIn, noYield> -- a1

  BitwiseORExpression<guardIn, guardYield> = 
    | BitwiseXORExpression<noIn, noYield> -- a0
    | BitwiseORExpression<noIn, noYield> "|" BitwiseXORExpression<noIn, noYield> -- a1

  LogicalANDExpression<guardIn, guardYield> = 
    | BitwiseORExpression<noIn, noYield> -- a0
    | LogicalANDExpression<noIn, noYield> "&&" BitwiseORExpression<noIn, noYield> -- a1

  LogicalORExpression<guardIn, guardYield> = 
    | LogicalANDExpression<noIn, noYield> -- a0
    | LogicalORExpression<noIn, noYield> "||" LogicalANDExpression<noIn, noYield> -- a1

  ConditionalExpression<guardIn, guardYield> = 
    | LogicalORExpression<noIn, noYield> -- a0
    | LogicalORExpression<noIn, noYield> "?" AssignmentExpression<noIn, noYield> ":" AssignmentExpression<noIn, noYield> -- a1

  AssignmentExpression<guardIn, guardYield> = 
    | ConditionalExpression<noIn, noYield> -- a0
    | guardYield YieldExpression<noIn> -- a1
    | ArrowFunction<noIn, noYield> -- a2
    | LeftHandSideExpression<noYield> "=" AssignmentExpression<noIn, noYield> -- a3
    | LeftHandSideExpression<noYield> AssignmentOperator AssignmentExpression<noIn, noYield> -- a4

  AssignmentOperator = "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="

  Expression<guardIn, guardYield> = 
    | AssignmentExpression<noIn, noYield> -- a0
    | Expression<noIn, noYield> "," AssignmentExpression<noIn, noYield> -- a1

  Statement<guardYield, guardReturn> = 
    | BlockStatement<noYield, noReturn> -- a0
    | VariableStatement<noYield> -- a1
    | EmptyStatement -- a2
    | ExpressionStatement<noYield> -- a3
    | IfStatement<noYield, noReturn> -- a4
    | BreakableStatement<noYield, noReturn> -- a5
    | ContinueStatement<noYield> -- a6
    | BreakStatement<noYield> -- a7
    | guardReturn ReturnStatement<noYield> -- a8
    | WithStatement<noYield, noReturn> -- a9
    | LabelledStatement<noYield, noReturn> -- a10
    | ThrowStatement<noYield> -- a11
    | TryStatement<noYield, noReturn> -- a12
    | DebuggerStatement -- a13

  Declaration<guardYield> = 
    | HoistableDeclaration<noYield, noDefault>
    | ClassDeclaration<noYield, noDefault>
    | LexicalDeclaration<noIn, noYield>

  HoistableDeclaration<guardYield, guardDefault> = 
    | FunctionDeclaration<noYield, noDefault>
    | GeneratorDeclaration<noYield, noDefault>

  BreakableStatement<guardYield, guardReturn> = 
    | IterationStatement<noYield, noReturn>
    | SwitchStatement<noYield, noReturn>

  BlockStatement<guardYield, guardReturn> = 
    | Block<noYield, noReturn>

  Block<guardYield, guardReturn> = 
    | "{" StatementList<noYield, noReturn>? "}" -- a0

  StatementList<guardYield, guardReturn> = 
    | StatementListItem<noYield, noReturn> -- a0
    | StatementList<noYield, noReturn> StatementListItem<noYield, noReturn> -- a1

  StatementListItem<guardYield, guardReturn> = 
    | Statement<noYield, noReturn>
    | Declaration<noYield>

  LexicalDeclaration<guardIn, guardYield> = 
    | LetOrConst BindingList<noIn, noYield> ";" -- a0

  LetOrConst = 
    | "let"
    | "const"

  BindingList<guardIn, guardYield> = 
    | LexicalBinding<noIn, noYield> -- a0
    | BindingList<noIn, noYield> "," LexicalBinding<noIn, noYield> -- a1

  LexicalBinding<guardIn, guardYield> = 
    | BindingIdentifier<noYield> Initializer<noIn, noYield>? -- a0
    | BindingPattern<noYield> Initializer<noIn, noYield> -- a1

  VariableStatement<guardYield> = 
    | "var" VariableDeclarationList<noIn, noYield> ";" -- a0

  VariableDeclarationList<guardIn, guardYield> = 
    | VariableDeclaration<noIn, noYield> -- a0
    | VariableDeclarationList<noIn, noYield> "," VariableDeclaration<noIn, noYield> -- a1

  VariableDeclaration<guardIn, guardYield> = 
    | BindingIdentifier<noYield> Initializer<noIn, noYield>? -- a0
    | BindingPattern<noYield> Initializer<noIn, noYield> -- a1

  BindingPattern<guardYield> = 
    | ObjectBindingPattern<noYield>
    | ArrayBindingPattern<noYield>

  ObjectBindingPattern<guardYield> = 
    | "{" "}" -- a0
    | "{" BindingPropertyList<noYield> "}" -- a1
    | "{" BindingPropertyList<noYield> "," "}" -- a2

  ArrayBindingPattern<guardYield> = 
    | "[" Elision? BindingRestElement<noYield>? "]" -- a0
    | "[" BindingElementList<noYield> "]" -- a1
    | "[" BindingElementList<noYield> "," Elision? BindingRestElement<noYield>? "]" -- a2

  BindingPropertyList<guardYield> = 
    | BindingProperty<noYield> -- a0
    | BindingPropertyList<noYield> "," BindingProperty<noYield> -- a1

  BindingElementList<guardYield> = 
    | BindingElisionElement<noYield> -- a0
    | BindingElementList<noYield> "," BindingElisionElement<noYield> -- a1

  BindingElisionElement<guardYield> = 
    | Elision? BindingElement<noYield> -- a0

  BindingProperty<guardYield> = 
    | SingleNameBinding<noYield> -- a0
    | PropertyName<noYield> ":" BindingElement<noYield> -- a1

  BindingElement<guardYield> = 
    | SingleNameBinding<noYield> -- a0
    | BindingPattern<noYield> Initializer<noIn, noYield>? -- a1

  SingleNameBinding<guardYield> = 
    | BindingIdentifier<noYield> Initializer<noIn, noYield>? -- a0

  BindingRestElement<guardYield> = 
    | "..." BindingIdentifier<noYield> -- a0

  EmptyStatement = 
    | ";"

  ExpressionStatement<guardYield> = 
    | /* FIXME Assertion: lookahead <! { `{`, `function`, `class`, `let` `[` } */ Expression<noIn, noYield> ";" -- a0

  IfStatement<guardYield, guardReturn> = 
    | "if" "(" Expression<noIn, noYield> ")" Statement<noYield, noReturn> "else" Statement<noYield, noReturn> -- a0
    | "if" "(" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a1

  IterationStatement<guardYield, guardReturn> = 
    | "do" Statement<noYield, noReturn> "while" "(" Expression<noIn, noYield> ")" ";" -- a0
    | "while" "(" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a1
    | "for" "(" /* FIXME Assertion: lookahead <! { `let` `[` } */ Expression<noIn, noYield>? ";" Expression<noIn, noYield>? ";" Expression<noIn, noYield>? ")" Statement<noYield, noReturn> -- a2
    | "for" "(" "var" VariableDeclarationList<noIn, noYield> ";" Expression<noIn, noYield>? ";" Expression<noIn, noYield>? ")" Statement<noYield, noReturn> -- a3
    | "for" "(" LexicalDeclaration<noIn, noYield> Expression<noIn, noYield>? ";" Expression<noIn, noYield>? ")" Statement<noYield, noReturn> -- a4
    | "for" "(" /* FIXME Assertion: lookahead <! { `let` `[` } */ LeftHandSideExpression<noYield> "in" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a5
    | "for" "(" "var" ForBinding<noYield> "in" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a6
    | "for" "(" ForDeclaration<noYield> "in" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a7
    | "for" "(" ~"let" LeftHandSideExpression<noYield> "of" AssignmentExpression<noIn, noYield> ")" Statement<noYield, noReturn> -- a8
    | "for" "(" "var" ForBinding<noYield> "of" AssignmentExpression<noIn, noYield> ")" Statement<noYield, noReturn> -- a9
    | "for" "(" ForDeclaration<noYield> "of" AssignmentExpression<noIn, noYield> ")" Statement<noYield, noReturn> -- a10

  ForDeclaration<guardYield> = 
    | LetOrConst ForBinding<noYield> -- a0

  ForBinding<guardYield> = 
    | BindingIdentifier<noYield>
    | BindingPattern<noYield>

  ContinueStatement<guardYield> = 
    | "continue" ";" -- a0
    | "continue" ~lineTerminator LabelIdentifier<noYield> ";" -- a1

  BreakStatement<guardYield> = 
    | "break" ";" -- a0
    | "break" ~lineTerminator LabelIdentifier<noYield> ";" -- a1

  ReturnStatement<guardYield> = 
    | "return" ";" -- a0
    | "return" ~lineTerminator Expression<noIn, noYield> ";" -- a1

  WithStatement<guardYield, guardReturn> = 
    | "with" "(" Expression<noIn, noYield> ")" Statement<noYield, noReturn> -- a0

  SwitchStatement<guardYield, guardReturn> = 
    | "switch" "(" Expression<noIn, noYield> ")" CaseBlock<noYield, noReturn> -- a0

  CaseBlock<guardYield, guardReturn> = 
    | "{" CaseClauses<noYield, noReturn>? "}" -- a0
    | "{" CaseClauses<noYield, noReturn>? DefaultClause<noYield, noReturn> CaseClauses<noYield, noReturn>? "}" -- a1

  CaseClauses<guardYield, guardReturn> = 
    | CaseClause<noYield, noReturn> -- a0
    | CaseClauses<noYield, noReturn> CaseClause<noYield, noReturn> -- a1

  CaseClause<guardYield, guardReturn> = 
    | "case" Expression<noIn, noYield> ":" StatementList<noYield, noReturn>? -- a0

  DefaultClause<guardYield, guardReturn> = 
    | "default" ":" StatementList<noYield, noReturn>? -- a0

  LabelledStatement<guardYield, guardReturn> = 
    | LabelIdentifier<noYield> ":" LabelledItem<noYield, noReturn> -- a0

  LabelledItem<guardYield, guardReturn> = 
    | Statement<noYield, noReturn>
    | FunctionDeclaration<noYield, noDefault>

  ThrowStatement<guardYield> = 
    | "throw" ~lineTerminator Expression<noIn, noYield> ";" -- a0

  TryStatement<guardYield, guardReturn> = 
    | "try" Block<noYield, noReturn> Catch<noYield, noReturn> -- a0
    | "try" Block<noYield, noReturn> Finally<noYield, noReturn> -- a1
    | "try" Block<noYield, noReturn> Catch<noYield, noReturn> Finally<noYield, noReturn> -- a2

  Catch<guardYield, guardReturn> = 
    | "catch" "(" CatchParameter<noYield> ")" Block<noYield, noReturn> -- a0

  Finally<guardYield, guardReturn> = 
    | "finally" Block<noYield, noReturn> -- a0

  CatchParameter<guardYield> = 
    | BindingIdentifier<noYield>
    | BindingPattern<noYield>

  DebuggerStatement = 
    | "debugger" ";" -- a0

  FunctionDeclaration<guardYield, guardDefault> = 
    | "function" BindingIdentifier<noYield> "(" FormalParameters<noYield> ")" "{" FunctionBody<noYield> "}" -- a0
    | guardDefault "function" "(" FormalParameters<noYield> ")" "{" FunctionBody<noYield> "}" -- a1

  FunctionExpression = 
    | "function" BindingIdentifier<noYield>? "(" FormalParameters<noYield> ")" "{" FunctionBody<noYield> "}" -- a0

  StrictFormalParameters<guardYield> = 
    | FormalParameters<noYield>

  FormalParameters<guardYield> = 
    | ""
    | FormalParameterList<noYield>

  FormalParameterList<guardYield> = 
    | FunctionRestParameter<noYield> -- a0
    | FormalsList<noYield> -- a1
    | FormalsList<noYield> "," FunctionRestParameter<noYield> -- a2

  FormalsList<guardYield> = 
    | FormalParameter<noYield> -- a0
    | FormalsList<noYield> "," FormalParameter<noYield> -- a1

  FunctionRestParameter<guardYield> = 
    | BindingRestElement<noYield>

  FormalParameter<guardYield> = 
    | BindingElement<noYield>

  FunctionBody<guardYield> = 
    | FunctionStatementList<noYield>

  FunctionStatementList<guardYield> = 
    | StatementList<noYield, noReturn>?

  ArrowFunction<guardIn, guardYield> = 
    | ArrowParameters<noYield> ~lineTerminator "=>" ConciseBody<noIn> -- a0

  ArrowParameters<guardYield> = 
    | BindingIdentifier<noYield>
    | CoverParenthesizedExpressionAndArrowParameterList<noYield>

  ConciseBody<guardIn> = 
    | ~"{" AssignmentExpression<noIn, noYield> -- a0
    | "{" FunctionBody<noYield> "}" -- a1

  MethodDefinition<guardYield> = 
    | PropertyName<noYield> "(" StrictFormalParameters<noYield> ")" "{" FunctionBody<noYield> "}" -- a0
    | GeneratorMethod<noYield> -- a1
    | "get" PropertyName<noYield> "(" ")" "{" FunctionBody<noYield> "}" -- a2
    | "set" PropertyName<noYield> "(" PropertySetParameterList ")" "{" FunctionBody<noYield> "}" -- a3

  PropertySetParameterList = 
    | FormalParameter<noYield>

  GeneratorMethod<guardYield> = 
    | "*" PropertyName<noYield> "(" StrictFormalParameters<noYield> ")" "{" GeneratorBody "}" -- a0

  GeneratorDeclaration<guardYield, guardDefault> = 
    | "function" "*" BindingIdentifier<noYield> "(" FormalParameters<noYield> ")" "{" GeneratorBody "}" -- a0
    | guardDefault "function" "*" "(" FormalParameters<noYield> ")" "{" GeneratorBody "}" -- a1

  GeneratorExpression = 
    | "function" "*" BindingIdentifier<noYield>? "(" FormalParameters<noYield> ")" "{" GeneratorBody "}" -- a0

  GeneratorBody = 
    | FunctionBody<noYield>

  YieldExpression<guardIn> = 
    | "yield" -- a0
    | "yield" ~lineTerminator AssignmentExpression<noIn, noYield> -- a1
    | "yield" ~lineTerminator "*" AssignmentExpression<noIn, noYield> -- a2

  ClassDeclaration<guardYield, guardDefault> = 
    | "class" BindingIdentifier<noYield> ClassTail<noYield> -- a0
    | guardDefault "class" ClassTail<noYield> -- a1

  ClassExpression<guardYield> = 
    | "class" BindingIdentifier<noYield>? ClassTail<noYield> -- a0

  ClassTail<guardYield> = 
    | ClassHeritage<noYield>? "{" ClassBody<noYield>? "}" -- a0

  ClassHeritage<guardYield> = 
    | "extends" LeftHandSideExpression<noYield> -- a0

  ClassBody<guardYield> = 
    | ClassElementList<noYield>

  ClassElementList<guardYield> = 
    | ClassElement<noYield> -- a0
    | ClassElementList<noYield> ClassElement<noYield> -- a1

  ClassElement<guardYield> = 
    | MethodDefinition<noYield> -- a0
    | "static" MethodDefinition<noYield> -- a1
    | ";" -- a2

  Script = 
    | ScriptBody?

  ScriptBody = 
    | StatementList<noYield, noReturn>

  Module = 
    | ModuleBody?

  ModuleBody = 
    | ModuleItemList

  ModuleItemList = 
    | ModuleItem -- a0
    | ModuleItemList ModuleItem -- a1

  ModuleItem = 
    | ImportDeclaration
    | ExportDeclaration
    | StatementListItem<noYield, noReturn>

  ImportDeclaration = 
    | "import" ImportClause FromClause ";" -- a0
    | "import" ModuleSpecifier ";" -- a1

  ImportClause = 
    | ImportedDefaultBinding -- a0
    | NameSpaceImport -- a1
    | NamedImports -- a2
    | ImportedDefaultBinding "," NameSpaceImport -- a3
    | ImportedDefaultBinding "," NamedImports -- a4

  ImportedDefaultBinding = 
    | ImportedBinding

  NameSpaceImport = 
    | "*" "as" ImportedBinding -- a0

  NamedImports = 
    | "{" "}" -- a0
    | "{" ImportsList "}" -- a1
    | "{" ImportsList "," "}" -- a2

  FromClause = 
    | "from" ModuleSpecifier -- a0

  ImportsList = 
    | ImportSpecifier -- a0
    | ImportsList "," ImportSpecifier -- a1

  ImportSpecifier = 
    | ImportedBinding -- a0
    | identifierName "as" ImportedBinding -- a1

  ModuleSpecifier = 
    | stringLiteral

  ImportedBinding = 
    | BindingIdentifier<noYield>

  ExportDeclaration = 
    | "export" "*" FromClause ";" -- a0
    | "export" ExportClause FromClause ";" -- a1
    | "export" ExportClause ";" -- a2
    | "export" VariableStatement<noYield> -- a3
    | "export" Declaration<noYield> -- a4
    | "export" "default" HoistableDeclaration<noYield, noDefault> -- a5
    | "export" "default" ClassDeclaration<noYield, noDefault> -- a6
    | "export" "default" /* FIXME Assertion: lookahead <! { `function`, `class` } */ AssignmentExpression<noIn, noYield> ";" -- a7

  ExportClause = 
    | "{" "}" -- a0
    | "{" ExportsList "}" -- a1
    | "{" ExportsList "," "}" -- a2

  ExportsList = 
    | ExportSpecifier -- a0
    | ExportsList "," ExportSpecifier -- a1

  ExportSpecifier = 
    | identifierName -- a0
    | identifierName "as" identifierName -- a1

  withYield = /* fixme */

  noYield = /* fixme */

  withIn = /* fixme */

  noIn = /* fixme */

  withReturn = /* fixme */

  noReturn = /* fixme */

  withDefault = /* fixme */

  noDefault = /* fixme */
}